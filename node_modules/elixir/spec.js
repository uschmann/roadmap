require('cheeba')(global);

var Elixir = require('./');
var R = Elixir.RaptorJuice;

describe('Elixir...', function() {

  describe('by use of...', function() {

    describe('ensure...', function() {

      it('can ensure a root', function() {
        var root = { };
        var elixir = new Elixir();
        var child = elixir.ensure(root);
        root.segments.should.be.defined;
        root.methods.should.be.defined;
        root.states.should.be.defined;
      });

      it('can ensure a segment', function() {
        var root = { };
        var elixir = new Elixir();
        var child = elixir.ensure(root, 'test');
        root.segments.test.should.equal(child);
        child.segments.should.be.defined;
        child.methods.should.be.defined;
        child.states.should.be.defined;
        child.parent.should.equal(root);
      });

    });

    describe('isEmpty...', function() {

      it('properly determines if a node contains any handlers', function() {
        var elixir = new Elixir();
        var node = { };
        elixir.ensure(node);
        elixir.isEmpty(node).should.be.true;
        elixir.add('/test/ing', 'on', function() { });
        var test = elixir.table.segments.test;
        elixir.isEmpty(test).should.be.true;
        elixir.isEmpty(test.segments.ing).should.be.false;
      });

      it('properly determines if a node contains handlers with a method',
          function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        var node = { };
        elixir.ensure(node);
        elixir.isEmpty(node).should.be.true;
        elixir.add('/test/ing', 'get', 'on', function() { });
        var test = elixir.table.segments.test;
        elixir.isEmpty(test).should.be.true;
        elixir.isEmpty(test.segments.ing).should.be.false;
      });

    });

    describe('isPertinent...', function() {

      var elixir;

      function alpha() { };
      function beta() { };

      beforeEach(function() {
        elixir = new Elixir()
          .add('/', 'on', alpha)
          .add('/test/ing/abc', 'on', beta);
      });

      describe('can determine the pertinence of...', function() {

        it('a "root" node', function() {
          elixir.isPertinent(elixir.table).should.be.true;
          elixir.remove('/test/ing/abc', 'on', beta);
          elixir.isPertinent(elixir.table).should.be.true;
          elixir.remove('/', 'on', alpha);
          elixir.isPertinent(elixir.table).should.be.false;
        });

        it('an intermediate node', function() {
          var node = elixir.table.segments.test.segments.ing;
          elixir.isPertinent(node).should.be.true;
          elixir.remove('/test/ing/abc', 'on', beta);
          elixir.isPertinent(node).should.be.false;
          elixir.remove('/', 'on', alpha);
          elixir.isPertinent(node).should.be.false;
        });

        it('a terminal node', function() {
          var node = elixir.table.segments.test.segments.ing.segments.abc;
          elixir.isPertinent(node).should.be.true;
          elixir.remove('/test/ing/abc', 'on', beta);
          elixir.isPertinent(node).should.be.false;
          elixir.remove('/', 'on', alpha);
          elixir.isPertinent(node).should.be.false;
        });

      });

    });

    describe('prune...', function() {

      it('properly removes a node from the tree', function() {
        var elixir = new Elixir();
        var root = { };
        var ing = elixir.make('/test/ing', root);
        elixir.prune(ing.parent);
        root.segments.should.eql({ });
        ing.parent.should.be.defined;
      });

    });

    describe('getStates...', function() {

      var elixir;

      function alpha() { }
      function beta() { }

      beforeEach(function() {
        elixir = new Elixir({ methods : [ 'get' ] })
          .add('/', 'on', alpha)
          .add('/test', 'get', 'on', beta);
      });

      it('returns the states object for a node', function() {
        elixir.getStates(elixir.table).on.should.eql([ alpha ]);
      });

      it('returns the states object for a node with a method', function() {
        elixir.getStates(elixir.table.segments.test, 'get')
          .on.should.eql([ beta ]);
      });

    });

    describe('modifyState...', function() {

      var elixir, node;

      function alpha() { }

      beforeEach(function() {
        elixir = new Elixir({ methods : [ 'get' ] });
        node = { };
      });

      it('can add handlers to a state', function() {
        elixir.modifyState(node, 'on', [ alpha ], 'add');
        node.states.on.should.eql([ alpha ]);
      });

      it('can add handlers to a state with a method', function() {
        elixir.modifyState(node, 'on', 'get', [ alpha ], 'add');
        node.methods.get.states.on.should.eql([ alpha ]);
      });

      it('can remove handlers from a state', function() {
        elixir.modifyState(node, 'on', [ alpha ], 'remove');
        node.states.on.should.eql([ ]);
      });

      it('can remove handlers from a state with a method', function() {
        elixir.modifyState(node, 'on', 'get', [ alpha ], 'remove');
        node.methods.get.states.on.should.eql([ ]);
      });

      it('properly cleans up empty nodes', function() {
        var ing = elixir.make('/test/ing', node);
        elixir.modifyState(ing, 'on', [ alpha ], 'add');
        elixir.modifyState(ing, 'on', [ alpha ], 'remove');
        elixir.isPertinent(ing).should.be.false;
        elixir.isPertinent(node).should.be.false;
      });

      it('properly cleans up empty branches', function() {
        var ing = elixir.make('/test/ing', node);
        elixir.modifyState(ing, 'on', [ alpha ], 'add');
        elixir.isPertinent(node).should.be.true;
        elixir.modifyState(ing, 'on', [ alpha ], 'remove');
        elixir.isPertinent(node).should.be.false;
        node.segments.should.be.empty;
      });

    });

    describe('make...', function() {

      it('can make a path', function() {
        var elixir = new Elixir();
        var context = elixir.make('/test/ing');
        elixir.table.segments.test.should.equal(context.parent);
      });

      it('can make a resource', function() {
        var elixir = new Elixir();
        var context = elixir.make('/test/ing::');
        context.parent.terminal.should.be.true;
      });

      it('throws an error when there are multiple terminators',
        function(done) {
        var elixir = new Elixir();
        try {
          var context = elixir.make('/test/ing::/::');
        } catch (error) {
          done();
        }
      });

      it('doesn\'t terminate a pertinent node', function(done) {
        var elixir = new Elixir();
        elixir.add('/test/ing', 'on', function() { });
        try {
          var context = elixir.make('/test/ing::');
        } catch (error) {
          done();
        }
      });

      it('doesn\'t create a node after a terminated node', function(done) {
        var elixir = new Elixir();
        var context = elixir.make('/test/ing::');
        var context = elixir.make('/test/ing::');
        try {
          var context = elixir.make('/test/ing/123');
        } catch (error) {
          done();
        }
      });

      it('can make a path with a callback', function(done) {
        var count = 3;
        var elixir = new Elixir();
        var valid = [ 'root', 'test', 'ing' ];
        elixir.make('/test/ing', function(branch) {
          R.contains(valid, branch.name).should.be.true;
          --count || done();
        });
      });

      it('errors on an invalid path', function() {
        var elixir = new Elixir();
        elixir.make('/test/ing/(\\d+)');
        try {
          var context = elixir.walk('/test/123');
        } catch(e) {
          e.message.should.equal('Elixir.walk: Path not found or' +
            ' improperly formed. Not all chunks have been consumed.');
        }
      });

      it('errors on an invalid group match', function() {
        var elixir = new Elixir();
        elixir.make('/test/ing/(\\d+/\\d+)');
        try {
          var context = elixir.walk('/test/ing/12');
        } catch(e) {
          e.message.should.equal('Elixir.walk: Path not found or' +
            ' improperly formed. Not all chunks have been consumed.');
          //e.message.should.equal('Elixir.test: Improperly formed path.' +
          //  ' Not all chunks have been consumed.');
        }
      });

      it('can properly generate a delimiter count table', function() {
        function alpha() { };
        function beta() { };
        function gamma() { };
        function delta() { };
        var elixir = new Elixir();
        elixir.make('/test/ing/(a/b)/(c/d/e)');
        elixir.table.dcount[0].test.should.be.defined;
        elixir.table.segments.test.dcount[0].ing.should.be.defined;
        elixir.table.segments.test.segments.ing
          .dcount[1]['(a/b)'].should.be.defined;
        elixir.table.segments.test.segments.ing
          .segments['(a/b)'].should.be.defined;
        elixir.table.segments.test.segments.ing
          .segments['(a/b)'].dcount[2]['(c/d/e)'].should.be.defined;
      });

    });

    describe('test...', function() {

      it('can determine if an iterator matches any of a node\'s segments',
        function() {
        var elixir = new Elixir();
        elixir.add('/test', 'on', function() { });
        var root = elixir.table;
        var chunks = R.iterate([ 'test' ]);
        var match = elixir.test(root, chunks);
        match.match.should.equal('test');
        match.node.should.equal(root.segments.test);
        chunks.push([ 'ing' ]);
        match = elixir.test(root, chunks);
        expect(match).to.be.undefined;
      });

      it('can determine if an iterator matches any of a node\'s grouped' +
          ' segments', function() {
        var elixir = new Elixir();
        elixir.add('/(test/ing/\\d+)', 'on', function() { });
        var root = elixir.table;
        var chunks = R.iterate([ 'test', 'ing', '123' ]);
        var match = elixir.test(root, chunks);
        match.match.should.equal('test/ing/123');
        match.node.should.equal(root.segments['(test/ing/\\d+)']);
      });

      it('consumes matched chunks', function() {
        var elixir = new Elixir();
        elixir.add('/(test/ing/\\d+)', 'on', function() { });
        var root = elixir.table;
        var chunks = R.iterate([ 'test', 'ing', '123', '456' ]);
        var match = elixir.test(root, chunks);
        match.match.should.equal('test/ing/123');
        match.node.should.equal(root.segments['(test/ing/\\d+)']);
        chunks.next().should.equal('456');
        expect(chunks.next()).to.be.undefined;
      });

    });

    describe('walk...', function() {

      var elixir;

      beforeEach(function() {
        elixir = new Elixir();
      });

      it('can walk the "root" path', function() {
        elixir.make('/');
        var context = elixir.walk('/');
        elixir.table.should.equal(context);
      });

      it('can walk the "root" path with a callback', function() {
        elixir.make('/');
        var context = elixir.walk('/')
        elixir.walk('/', function(branch, node) {
          branch.should.equal(context); 
        });
      });

      it('can walk a path', function() {
        elixir.make('/test/ing');
        var context = elixir.walk('/test/ing');
        elixir.table.segments.test.should.equal(context.parent);
      });

      it('can walk a path with a callback', function(done) {
        var count = 3;
        elixir.make('/test/ing');
        var valid = [ 'root', 'test', 'ing' ];
        var context = elixir.walk('/test/ing', function(branch, match, x) {
          R.contains(valid, match).should.be.true;
          R.contains(valid, branch.name).should.be.true;
          --count || done();
        });
        elixir.table.segments.test.should.equal(context.parent);
      });

      it('can walk a path with a group', function(done) {
        var count = 2;
        var valid = [ 'root', '123' ];
        elixir.make('/(\\d+)');
        var context = elixir.walk('/123', function(branch, match) {
          R.contains(valid, match).should.be.true;
          --count || done();
        });
      });

      it('can walk a path with a split group', function(done) {
        var count = 2;
        var valid = [ 'root', '12/34' ];
        elixir.make('/(\\d+/\\d+)');
        var context = elixir.walk('/12/34', function(branch, match) {
          R.contains(valid, match).should.be.true;
          --count || done();
        });
      });

      it('can walk a path with a nested group', function(done) {
        var count = 4;
        var valid = [ 'root', 'test', 'ing', '123' ];
        elixir.make('/test/ing/(\\d+)');
        var context = elixir.walk('/test/ing/123', function(branch, match) {
          R.contains(valid, match).should.be.true;
          --count || done();
        });
        elixir.table.segments.test.segments.ing
          .should.equal(context.parent);
      });

      it('can walk a path with a split, nested group', function(done) {
        var count = 4;
        var valid = [ 'root', 'test', 'ing', '12/34' ];
        //elixir.make('/test/ing/(\\d+)/\\d+');
        //// XXX: This route was created
        // Not cool.
        elixir.make('/test/ing/(\\d+/\\d+)');
        var context = elixir.walk('/test/ing/12/34',function(branch, match){
          R.contains(valid, match).should.be.true;
          --count || done();
        });
        elixir.table.segments.test.segments.ing
          .should.equal(context.parent);
      });

    });

    describe('add...', function() {

      it('respects allowable methods', function() {
        var elixir = new Elixir();
        var alpha = function() { };
        try {
          elixir.add('/test/ing', 'get', 'on', alpha);
        } catch(e) {
          e.message.should.equal('Unsupported Method: get');
        }
      });

      it('respects allowable states', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        var alpha = function() { };
        try {
          elixir.add('/test/ing', 'get', 'invalid', alpha);
        } catch(e) {
          e.message.should.equal('Unsupported State: invalid');
        }
      });


      it('can add the "root" handler', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/', 'get', 'on', alpha);
        elixir.table.methods.get.states.on.should.eql([ alpha ]);
      });

      it('can add a handler', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/test/ing', 'get', 'on', alpha);
        elixir.table.segments.test.segments.ing.methods
          .get.states.on.should.eql([ alpha ]);
      });

      it('can nest handlers', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        function beta() { };
        function gamma() { };
        function delta() { };
        elixir.add('/', 'get', 'on', alpha);
        elixir.add('/test', 'get', 'on', beta);
        elixir.add('/test/ing', 'get', 'on', gamma);
        elixir.table.methods.get.states.on.should.eql([ alpha ]);
        elixir.table.segments.test.methods
          .get.states.on.should.eql([beta]);
        elixir.table.segments.test.segments
          .ing.methods.get.states.on.should.eql([ gamma ]);
      });

      it('can nest grouped handlers', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        function beta() { };
        function gamma() { };
        function delta() { };
        elixir.add('/', 'get', 'on', alpha);
        elixir.add('/(\\d+)', 'get', 'on', beta);
        elixir.add('/(\\d+)/([A-Za-z]+)', 'get', 'on', gamma);
        elixir.table.methods.get.states.on.should.eql([ alpha ]);
        elixir.table.segments['(\\d+)']
          .methods.get.states.on.should.eql([beta]);
        elixir.table.segments['(\\d+)'].segments['([A-Za-z]+)']
          .methods.get.states.on.should.eql([ gamma ]);
      });

    });

    describe('lookup...', function() {

      it('can get functions for a state', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/', 'on', alpha);
        elixir.lookup('/', 'on').should.eql([ alpha ]);
      });

      it('can get functions for a method and state', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/', 'get', 'on', alpha);
        elixir.lookup('/', 'get', 'on').should.eql([ alpha ]);
      });

      it('can get functions for a grouped segment', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/(test/ing)', 'get', 'on', alpha);
        elixir.lookup('/(test/ing)', 'get', 'on').should.eql([ alpha ]);
      });

    });

    describe('find...', function() {

      it('can get functions for a state', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/', 'on', alpha);
        elixir.find('/', 'on').should.eql([ alpha ]);
      });

      it('can get functions for a method and state', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/', 'get', 'on', alpha);
        elixir.find('/', 'get', 'on').should.eql([ alpha ]);
      });

      it('can get functions for a grouped segment', function() {
        var elixir = new Elixir({ methods : [ 'get' ] });
        function alpha() { };
        elixir.add('/(test/ing)', 'get', 'on', alpha);
        elixir.find('/test/ing', 'get', 'on').should.eql([ alpha ]);
      });

    });

    describe('remove...', function() {

      it('can remove functions from a state', function() {
        var elixir = new Elixir();
        function alpha() { };
        elixir.add('/', 'on', alpha);
        elixir.lookup('/', 'on').should.eql([ alpha ]);
        elixir.remove('/', 'on').should.eql([ alpha ]);
        elixir.lookup('/', 'on').should.eql([ ]);
      });

    });

    describe('traverse...', function() {

      var elixer, context, test;

      beforeEach(function() {
        elixir = new Elixir();
        context = { };
        test = [ ];
      });

      it('can traverse the "root"', function(done) {
        elixir.add('/', 'before', function() {
          test.push(1);
          this.next();
        });

        elixir.add('/', 'on', function() {
          test.push(2);
          this.next();
        });

        elixir.add('/', 'after', function() {
          test.push(3);
          this.next();
        });

        var layers = R.iterate(elixir.match('/'));
        elixir.traverse(context, layers, null, function() {
          test.should.eql([ 1, 2, 3 ]);
          done();
        });
      });

      it('can traverse a first tier match', function(done) {
        elixir.add('/', 'before', function() {
          test.push(1);
          this.next();
        });

        elixir.add('/test', 'before', function() {
          test.push(2);
          this.next();
        });

        elixir.add('/test', 'on', function() {
          test.push(3);
          this.next();
        });

        elixir.add('/test', 'after', function() {
          test.push(4);
          this.next();
        });

        elixir.add('/', 'after', function() {
          test.push(5);
          this.next();
        });

        var layers = R.iterate(elixir.match('/test'));
        elixir.traverse(context, layers, null, function() {
          test.should.eql([ 1, 2, 3, 4, 5 ]);
          done();
        });
      });

      it('can traverse a second tier match', function(done) {
        elixir.add('/', 'before', function() {
          test.push(1);
          this.next();
        });

        elixir.add('/test', 'before', function() {
          test.push(2);
          this.next();
        });

        elixir.add('/test/ing', 'on', function() {
          test.push(3);
          this.next();
        });

        elixir.add('/test', 'after', function() {
          test.push(4);
          this.next();
        });

        elixir.add('/', 'after', function() {
          test.push(5);
          this.next();
        });

        var layers = R.iterate(elixir.match('/test/ing'));
        elixir.traverse(context, layers, null, function() {
          test.should.eql([ 1, 2, 3, 4, 5 ]);
          done();
        });
      });

      it('can traverse a third tier match', function(done) {
        elixir.add('/', 'before', function() {
          test.push(1);
          this.next();
        });

        elixir.add('/test', 'before', function() {
          test.push(2);
          this.next();
        });

        elixir.add('/test/ing/123', 'on', function() {
          test.push(3);
          this.next();
        });

        elixir.add('/test', 'after', function() {
          test.push(4);
          this.next();
        });

        elixir.add('/', 'after', function() {
          test.push(5);
          this.next();
        });

        var layers = R.iterate(elixir.match('/test/ing/123'));
        elixir.traverse(context, layers, null, function() {
          test.should.eql([ 1, 2, 3, 4, 5 ]);
          done();
        });
      });

      it('can handle an overlapping match', function() {
        function alpha() { }
        function beta() { }
        elixir.add('/test', 'on', alpha);
        elixir.add('/(test/ing)', 'on', beta);
        elixir.find('/test', 'on').should.eql([ alpha ]);
        elixir.find('/test/ing', 'on').should.eql([ beta ]);
      });

      it('can throw an error', function(done) {
        elixir.add('/', 'before', function() {
          test.push(1);
          this.next({ msg : 'error' });
        });
        elixir.add('/', 'on', function() {
          test.push(2);
          this.next();
        });

        elixir.add('/', 'after', function() {
          test.push(3);
          this.next();
        });

        var layers = R.iterate(elixir.match('/'));
        elixir.traverse(context, layers, null, function() {
          this.error.msg.should.equal('error');
          test.should.eql([ 1 ]);
          done();
        });
      });

      it('properly supplies a context', function(done) {
        elixir.add('/', 'before', function() {
          test.push(1);
          this.should.equal(context);
          this.next();
        });

        var layers = R.iterate(elixir.match('/'));
        elixir.traverse(context, layers, null, function() { 
          test.should.eql([ 1 ]);
          done();
        });
      });

      it('properly supplies a match', function(done) {
        elixir.add('/', 'before', function(param) {
          test.push(1);
          param.should.equal('root');
          this.next();
        });

        elixir.add('/test', 'before', function(param) {
          test.push(2);
          param.should.equal('test');
          this.next();
        });

        elixir.add('/test', 'on', function(param) {
          test.push(3);
          param.should.equal('test');
          this.next();
        });

        var layers = R.iterate(elixir.match('/test'));
        elixir.traverse(context, layers, null, function() { 
          test.should.eql([ 1, 2, 3 ]);
          done();
        });
      });

      it('fires methods in the proper order', function(done) {
        elixir = new Elixir({ methods : [ 'get' ] });

        elixir.add('/', 'before', function() {
          this.test.push(1);
          this.next();
        });
        elixir.add('/', 'get', 'before', function() {
          this.test.push(2);
          this.next();
        });

        elixir.add('/', 'on', function() {
          this.test.push(3);
          this.next();
        });
        elixir.add('/', 'get', 'on', function() {
          this.test.push(4);
          this.next();
        });

        elixir.add('/', 'after', function() {
          this.test.push(5);
          this.next();
        });
        elixir.add('/', 'get', 'after', function() {
          this.test.push(6);
          this.next();
        });

        elixir.trigger('/', 'get', { test : [ ] }, function() {
          this.test.should.eql([ 1, 2, 3, 4, 6, 5 ]);
          done();
        });
      });

      it('fires stacked functions in the proper order', function(done) {
        elixir = new Elixir({ methods : [ 'get' ] });

        elixir.add('/', 'before', function() {
          this.test.push(1);
          this.next();
        });
        elixir.add('/', 'get', 'before', function() {
          this.test.push(2);
          this.next();
        });

        elixir.add('/', 'on', function() {
          this.test.push(3);
          this.next();
        });
        elixir.add('/', 'get', 'on', function() {
          this.test.push(4);
          this.next();
        });

        elixir.add('/', 'after', function() {
          this.test.push(5);
          this.next();
        });
        elixir.add('/', 'get', 'after', function() {
          this.test.push(6);
          this.next();
        });

        elixir.add('/', 'before', function() {
          this.test.push(7);
          this.next();
        });
        elixir.add('/', 'get', 'before', function() {
          this.test.push(8);
          this.next();
        });

        elixir.add('/', 'on', function() {
          this.test.push(9);
          this.next();
        });
        elixir.add('/', 'get', 'on', function() {
          this.test.push(10);
          this.next();
        });

        elixir.add('/', 'after', function() {
          this.test.push(11);
          this.next();
        });
        elixir.add('/', 'get', 'after', function() {
          this.test.push(12);
          this.next();
        });
        elixir.trigger('/', 'get', { test : [ ] }, function() {
          this.test.should.eql([ 1, 7, 2, 8, 3, 9, 4, 10, 6, 12, 5, 11 ]);
          done();
        });
      });

    });

    describe('trigger...', function() {

      var elixir = new Elixir({ methods : [ 'get', 'post' ] })
        .add('/', 'before', function() {
          this.test.push(1);
          this.next();
        })
        .add('/', 'on', function() {
          this.test.push(2);
          this.next();
        })
        .add('/', 'after', function() {
          this.test.push(3);
          this.next();
        })
        .add('/some', 'before', function() {
          this.test.push(4);
          this.next();
        })
        .add('/some', 'on', function() {
          this.test.push(5);
          this.next();
        })
        .add('/some', 'after', function() {
          this.test.push(6);
          this.next();
        })
        .add('/some/path', 'before', function() {
          this.test.push(7);
          this.next();
        })
        .add('/some/path', 'on', function() {
          this.test.push(8);
          this.next();
        })
        .add('/some/path', 'after', function() {
          this.test.push(9);
          this.next();
      });

      it('can trigger the "root"', function(done) {
        var context = { test : [ ] };
        elixir.trigger('/', null, context, function() {
          this.test.should.eql([ 1, 2, 3 ]);
          done(); 
        });
      });

      it('can trigger a "root" match', function(done) {
        var context = { test : [ ] };
        elixir.add('/(\\d+)', 'on', function(match) {
          match.should.equal('123');
          this.test.push(42);
          this.next();
        });
        elixir.trigger('/123', null, context, function() {
          this.test.should.eql([ 1, 42, 3 ]);
          done(); 
        });
      });

      it('can trigger a first tier event', function(done) {
        elixir.trigger('/some', null, { test : [ ] }, function() {
          this.test.should.eql([ 1, 4, 5, 6, 3 ]);
          done(); 
        });
      });

      it('can trigger a second tier event', function(done) {
        elixir.trigger('/some/path', null, { test : [ ] }, function() {
          this.test.should.eql([ 1, 4, 7, 8, 9, 6, 3 ]);
          done(); 
        });
      });

      it('can trigger a third tier event with a match', function(done) {
        function method(match) {
          match.should.equal('123');
          this.test.push(10);
          this.next();
        }
        elixir.add('/some/path/(\\d+)', 'on', method);
        elixir.trigger('/some/path/123', null, { test : [ ] }, function() {
          this.test.should.eql([ 1, 4, 7, 10, 9, 6, 3 ]);
          done(); 
        });
      });

      it('can trigger a grouped third tier event with a match',
          function(done) {
        elixir.add('/some/path/(\\d+/\\d+)', 'on', function(match) {
          match.should.equal('12/34');
          this.test.push(10);
          this.next();
        });
        elixir.trigger('/some/path/12/34', null, { test : [ ] }, function(){
          this.test.should.eql([ 1, 4, 7, 10, 9, 6, 3 ]);
          done(); 
        });
      });

      it('can trigger a grouped "root" match', function(done) {
        var context = { test : [ ] };
        elixir.add('/(\\d+/\\d+/\\d+)', 'on', function(match) {
          match.should.equal('12/34/56');
          this.test.push(77);
          this.next();
        });
        elixir.trigger('/12/34/56', null, context, function() {
          this.test.should.eql([ 1, 77, 3 ]);
          done(); 
        });
      });

      it('can trigger a stacked, grouped "root" match with a method',
          function(done) {
        var context = { test : [ ] };
        elixir.add('/(\\d+/\\d+/\\d+)', 'get', 'on', function(match) {
          match.should.equal('12/34/56');
          this.test.push(7);
          this.next();
        });
        elixir.trigger('/12/34/56', 'get', context, function() {
          this.test.should.eql([ 1, 77, 7, 3 ]);
          done(); 
        });
      });

    });

  });

  it('can be nested', function(done) {
    var alpha = new Elixir();
    var beta = new Elixir();

    beta.add('/jungle/fresh', 'on', function() {
      done();
    });

    alpha.add('/test/ing::', 'on', function(resource) {
      resource.should.equal('jungle/fresh');
      beta.trigger(resource);
    });

    alpha.trigger('/test/ing/jungle/fresh');
  });

  it('can be deeply nested', function(done) {
    var alpha = new Elixir();
    var beta = new Elixir();
    var gamma = new Elixir()

    gamma.add('/fresh', 'on', function(match) {
      match.should.equal('fresh');
      done();
    });

    beta.add('/jungle::', 'on', function(resource) {
      gamma.trigger(resource);
    });

    alpha.add('/test/ing::', 'on', function(resource) {
      resource.should.equal('jungle/fresh');
      beta.trigger(resource);
    });

    alpha.trigger('/test/ing/jungle/fresh');
  });

});
