var R = require('raptorjuice');

/**
 *  @class
 */
function Elixir(opts) {

  opts = opts || { };

  /**
   *  The routing table.
   */
  this.table = { };

  /**
   *  Asynchronous traversal.
   *
   *  @default true
   */
  this.async = opts.async || true;

  /**
   *  Allowed `before` states.
   *
   *  @default [ 'before' ]
   */
  this.before = opts.before || [ 'before' ];

  /**
   *  Allowed `on` states.
   *
   *  @default [ 'on' ]
   */
  this.on = opts.on || [ 'on' ];

  /**
   *  Allowed `after` states.
   *
   *  @default [ 'after' ]
   */
  this.after = opts.after || [ 'after' ];

  /**
   *  All allowed states, in order.
   *
   *  @default [ 'before', 'on', 'after' ]
   */
  this.states = R.flatten([ this.before, this.on, this.after ]);

  /**
   *  Immutable settings.
   */
  var settings = { };
  this.get = function(key) { return settings[key]; };

  /**
   *  Allowed methods.
   *
   *  @default [ ]
   */
  this.methods = opts.methods || [ ];

  /**
   *  An array of tokens to replace in a endpoint before the route is added
   *  to the routing table.
   *
   *  @default [ ]
   */
  this.tokens = opts.tokens || [ ];

  /**
   *  The delimiter used to split endpoints.
   *
   *  @default /
   */
  this.delimiter = opts.delimiter || '/';

  /**
   *  
   *
   *  @default :
   */
  this.terminator = opts.terminator || ':';

};

/**
 *  Attach the
 *  [`RaptorJuice`](https://github.com/junglefresh/RaptorJuice.js)
 *  namespace. Its aliases are:
 *  
 *  * `RaptorJuice`
 *  * `Raptor`
 *  * `R`
 */
Elixir.RaptorJuice = Elixir.Raptor = Elixir.R = R;


Elixir.prototype = {

  /**
   *  Ensures that the `node` is properly structured. If `segment` is
   *  provided, the segment's existence as a child of `node` will be
   *  ensured as will the child's structure.
   *
   *  @param {object}         node - The `node` to ensure.
   *  @param {string|regex}   [segment] - The `segment` to ensure.
   *  @returns The ensured `node` if no `segment` was provided, or the
   *    ensured `segment` as a child of `node`.
   */
  ensure : function(node, segment) {
    // TODO: Check the validity of and escape each segment.
    var states, count, dcount;
    // This logic structure may seem confusing at first, but there is cause.
    // Why not factor this into a single function? This nested structure
    // allows us to easily create a reference to a child's parent.
    R.ensure(node, 'segments');
    R.ensure(node, 'methods');
    states = R.ensure(node, 'states');
    R.each(this.states, function(state) { 
      R.ensure(states, state, [ ]);
    });
    R.ensure(node, 'name', 'root');
    var child = null;
    if(segment) {
      child = R.ensure(node.segments, segment);
      R.ensure(child, 'segments');
      R.ensure(child, 'methods');
      states = R.ensure(child, 'states');
      R.each(this.states, function(state) { 
        R.ensure(states, state, [ ]);
      });
      R.ensure(child, 'parent', node);
      R.ensure(child, 'name', segment);
      // Count the number of delimiting characters in the segment. This
      // value is used in the `test` method, to determine how many chunks to
      // consume for each segment. This is because regex groups are allowed
      // to contain the delimiting character.
      count = R.count(child.name, this.delimiter);
      dcount = R.ensure(R.ensure(node, 'dcount'), count);
      dcount[child.name] = true;
    }
    // If no segment was provided, ensure the node and return it.
    // Otherwise, ensure the node, create a child and return the child.
    return child || node;
  },

  /**
   *  Determines if `node` contains any handlers.
   *
   *  @param {object}   node - The node to check.
   */
  isEmpty : function(node) {
    var handlers = R.iterate();
    var states = R.iterate(this.states);
    var methods = R.iterate(this.methods);
    for(var state; state = states.next(); state) {
      handlers.push(node.states[state]);
      methods.reset();
      for(var method; method = methods.next(); method) {
        if(node.methods[method]) {
          handlers.push(node.methods[method].states[state]);
        }
      }
    }
    return !handlers.remaining();
  },

  /**
   * Determines if there are any handlers at, or above `node`.
   *
   * @param {object}  node - The node to start at.
   * @returns {boolean} True, if there are handlers above the node, else
   *  false.
   */
  isPertinent : function(node) {
    var child = null;
    if(!this.isEmpty(node)) { return true; }
    for(var segment in node.segments) {
      child = node.segments[segment];
      if(!this.isEmpty(child) || this.isPertinent(child)) {
        return true;
      }
    }
    return false;
  },

  /**
   *  Cleanly removes a node from its parent.
   *
   *  @param {object}   node - The node to remove.
   *  @returns {object} The node which was removed from the tree.
   */
  prune : function(node, opts) {
    if(node.name === 'root') { return undefined; }
    var count = R.count(this.delimiter, node.name);
    delete node.parent.segments[node.name];
    delete node.parent.dcount[count][node.name];
    if(R.isEmpty(node.parent.dcount[count])) {
      delete node.parent.dcount[count];
    }
    var parents = R.iterate([ node.parent ]).generate(function(u) {
      return u(-1).parent;
    });
    var parent;
    do {
      parent = parents.next();
      this.prune(parent);
    } while(parents.remaining() && !this.isPertinent(parent));
    delete node.parent;
    return node;
  },

  /**
   *  Return the states table for a `node` or a `node`'s `method` if
   *  provided.
   *
   *  @param {object}   node - The `node` in consideration.
   *  @param {string}   method - The `method` to look in `node` for.
   *  @returns {array} The states table for a `node` or a `node`'s `method`.
   */
  getStates : function(node, method) {
    node = this.ensure(node);
    if(!method) { return node.states; }
    if(!R.contains(this.methods, method)) {
      throw new Error('Unsupported Method: ' + method);
    }
    // Ensure a method's `states` object.
    var method = R.ensure(node.methods, method, { states : { } });
    R.each(this.states, function(state) { 
      R.ensure(method.states, state, [ ]);
    });
    return method.states;
  },

  /**
   *  Modify the state of the routing table.
   *
   *  @param {object}           node - The `node` to begin at.
   *  @param {string}           state - The `state` to modify.
   *  @param {string}           [method] - The `method` to modify.
   *  @param {function|array}   handlers - The `handlers` to apply.
   *  @param {function}         action - The `action` to take.
   */
  modifyState : function(node, state, method, handlers, action) {
    if(R.isUndefined(action)) {
      action = handlers; handlers = method; method = null;
    }
    if(!R.contains(this.states, state)) {
      throw new Error('Unsupported State: ' + state);
    }
    // TODO: This if statement should be more explicit.
    if(R.isFunction(handlers)) { handlers = [ handlers ]; }
    // TODO: Verify parameters here.
    var states = this.getStates(node, method);
    switch(action) {
      case 'add' :
        R.flatten(handlers, states[state]);
        break;
      case 'remove' :
        var replace = [ ];
        var removed = [ ];
        // Iterate through existing handlers and see if they exist in the
        // array of handlers passed as a parameter. If true, add them to
        // the list of handlers to be removed, else, add them to the
        // replacement list.
        if( !handlers ) { handlers = states[state]; }
        R.each(states[state], function(handler) {
          ( R.contains(handlers, handler) ?
            removed : replace ).push(handler);
        });
        states[state] = replace;
        if( !this.isPertinent(node) ) {
          this.prune(node, { parents: true, children : true });
        }
        return removed;
      default :
        throw new Error('Elixir.modifyState: Unsupported action - '+action);
    }
  },

  /**
   *  Get the state list for a `node`'s state or `node`'s `method`'s
   *  state.
   *
   *  @param {object}   node - A `node` of the routing table.
   *  @param {string}   state - The `state` to look for.
   *  @param {string}   [method] - The `method` to look for.
   *  @returns {array}  The array at the given endpoint.
   */
  getState : function(node, state, method) {
    return this.getStates(node, method)[state];
  },

  /**
   *  Determines if the subsequent remaining `chunks` satisfy any of
   *  `node`'s segments. If a match is found, the child node is
   *  returned and the necessary chunks are consumed.
   *
   *  @param {object}   node - The node to match against.
   *  @param {object}   chunks - An `iterator` created from an array
   *                             of chunks.
   *  @returns {object} Returns the child node if a match is found,
   *    else *undefined*.
   */
  test : function(node, chunks) {
    var dcount;
    var dcounts = [ ];
    for(dcount in node.dcount) { dcounts.push(dcount); }
    // Create a reversed iterator over all of this node's dcounts.
    dcounts = R.iterate(dcounts).reversed();
    // 1 While there are dcounts remaining...
    while(dcounts.remaining()) {
      var temp = chunks.copy();
      // 1 Get the next dcount.
      dcount = dcounts.next();
      // 1.1 If there are less chunks remaining than the current dcount...
      if(chunks.remaining() < dcount) { return undefined; } // 1 :: END
      // 2 Otherwise...
      // 2.1 Glob together `dcount` segments from `chunks`, but do not
      // actually consume the chunks. A temporary iterator, `temp`, is
      // used to achieve this.
      var glob = [ ];
      for(var i = 0; i <= dcount; i++) {
        if(temp.remaining()) { glob.push(temp.next()); }
      }
      // 2.2 Combine the `glob` by our `delimiter` into `chunk`.
      var chunk = glob.join(this.delimiter);
      // 2.3 Get the the `node`s `segments` for this `dcount`.
      var segments = node.dcount[dcount];
      // 3 For each `segment`...
      for(var segment in segments) {
        // 3.1 Attempt to match the `chunk` against the current `segment`.
        var match = RegExp(segment).exec(chunk);
        // 3.2 If there was a match...
        if(match) {
          // 3.2.1 Actually consume the number of segments used from the
          // original iterator, `chunks`.
          for(var i = 0; i <= dcount; i++) {
            chunks.next();
          }
          // 3.3 Return the `match` and the matched `node`.
          var groups = R.iterate(match);
          return { 
            node : node.segments[segment], match : groups.pop(1)[0],
            groups : groups, segments : chunks.copy()
          }; // 3 :: RETURN
        }
        // 3 :: CONTINUE
      }
    }
    // 1 :: RETURN
  },

  /**
   *  Make `endpoint`, starting from `root`. Execute `callback` for each
   *  node of the routing table on the way to the endpoint. The callback
   *  will be passed the current node as its only parameter. Non-existent
   *  nodes will be created as they are needed.
   *
   *  @param {string|regex}   endpoint - The endpoint to make.
   *  @param {object}         root - The node to begin with.
   *  @param {function}       callback - The function to call on each node.
   *  @returns {object} The node at the end of `endpoint`.
   */
  make : function(endpoint, root, callback) {
    if(R.isFunction(root) && R.isUndefined(callback)) {
      callback = root; root = null;
    }
    var self = this;
    var node = root || this.table;
    endpoint = R.tokenize(endpoint, this.tokens);
    // Remove each occurance of two or more `this.terminator`s in a row and
    // replace them with only two `this.terminator`s. Also, only clamp the
    // beginning of `endpoint`.
    endpoint = R.sanitize(endpoint, this.terminator, 2, 2, -1);
    var parts = endpoint.split(this.terminator + this.terminator);
    var resource = parts[0];
    var terminal = ( parts[1] === '' ? true : false );
    if(R.isDefined(parts[2])) {
      throw new Error('Elixir.make: Improperly formed endpoint.');
    }
    if(terminal) {
      resource += this.delimiter + '(.*)';
    }
    resource = R.sanitize(resource, this.delimiter);
    resource = R.regify(resource);
    var segments = R.iterate(R.split(resource, this.delimiter));
    // Add the root node.
    callback && callback(self.ensure(node));
    // Iterate through other nodes.
    for(var segment; segment = segments.next();) {
      if(node.terminal && !( segment === '(.*)' ) ) {
        throw new Error('Elixir.make: Trying to travel past a terminal ' +
          'node.');
      }
      if( terminal && !segments.remaining() ) {
        if( this.isPertinent(node) ) {
          throw new Error('Elixir.make: Trying to terminate a pertinent ' +
            'node.');
        }
        node.terminal = true;
      }
      node = self.ensure(node, segment);
      callback && callback(node);
    }
    return node;
  },

  /**
   *  Using `endpoint`, dynamically traverse the routing table starting at 
   *  `root`. 
   *
   *  @param {string|regex}   endpoint - The endpoint to make.
   *  @param {object}         root - The node to begin with.
   *  @param {function}       callback - The function to call on each node.
   *  @returns {object} The node at the end of `endpoint`.
   */
  walk : function(endpoint, root, callback) {
    if(R.isFunction(root) && R.isUndefined(callback)) {
      callback = root; root = null;
    }
    var self = this;
    var node = root || this.table;
    var temp = endpoint.split(this.delimiter);
    var chunks = [ ];
    // Filter false values.
    for(var i in temp) { temp[i] && chunks.push(temp[i]); }
    chunks = R.iterate(chunks);
    // The faux iterator exists for handler uniformity.
    callback && callback(node, node.name, R.iterate());
    var match;
    while(match = this.test(node, chunks)) {
      node = match.node;
      callback && callback(node, match.match, match.groups, match.segments);
      if(node.terminal) {
        var path = (chunks.pop(chunks.index()+1, chunks.remaining()) || [ ])
          .join(this.delimiter);
        node = node.segments['(.*)'];
        callback && callback(node, path);
      }
    };
    if(chunks.remaining()) {
      throw new Error('Elixir.walk: Path not found or improperly formed. ' +
        'Not all chunks have been consumed.');
    }
    return node;
  },

  /**
   *  Insert `handlers` into the routing table.
   *
   *  @param {string}   endpoint - The endpoint to walk.
   *  @param {string}   method - An allowable method.
   *  @param {string}   state - An allowable state.
   *  @param {function|array} handler - A function or list of functions to
   *                                    be retrieved upon route traversal.
   */
  add : function(endpoint, method, state, handlers) {
    if(R.isUndefined(handlers)) {
      handlers = state; state = method; method = null;
    }
    state = state || 'on';
    this.modifyState(this.make(endpoint), state, method, handlers, 'add');
    return this;
  },

  /**
   *  Remove `handlers` from the routing table.
   *
   *  @param {string}   endpoint - The endpoint to walk.
   *  @param {string}   method - An allowable method.
   *  @param {string}   state - An allowable state.
   *  @param {function|array} handler - A function or list of functions to
   *                                    be retrieved upon route traversal.
   *  @returns {array} An array containing the removed items.
   */
  remove : function(endpoint, method, state, handlers) {
    if(R.isUndefined(handlers)) {
      handlers = state; state = method; method = null;
    }
    state = state || 'on';
    return this.modifyState(this.make(endpoint),
        state, method, handlers, 'remove');
  },

  /**
   *  Retrieve the list of functions at the endpoint.
   *
   *  @param {string}   endpoint - The endpoint to walk.
   *  @param {string}   [method] - The method to look for.
   *  @param {string}   state - The state to modify.
   *  @returns {array}  The list of functions at the endpoint.
   */
  find : function(endpoint, method, state) {
    if(R.isUndefined(state)) { state = method; method = null; }
    return this.getState(this.walk(endpoint), state, method);
  },

  /**
   *  Retrieve the list of functions at the endpoint.
   *
   *  @param {string}   endpoint - The endpoint to walk.
   *  @param {string}   [method] - The method to look for.
   *  @param {string}   state - The state to modify.
   *  @returns {array}  The list of functions at the endpoint.
   */
  lookup : function(endpoint, method, state) {
    if(R.isUndefined(state)) { state = method; method = null; }
    return this.getState(this.make(endpoint), state, method);
  },

  /**
   *  Compile a list of functions belonging to `endpoint` and `method`, if
   *  supplied.
   *
   *  @param {string}   endpoint - The endpoint to walk.
   *  @param {string}   [method] - The method to look for.
   *  @returns {array}  An ordered list of functions for `endpoint` and
   *    `method`.
   */
  match : function(endpoint) {
    var layers = [ ];
    this.walk(endpoint, function(node, match) {
      layers.push({ node : node, match : match });
    });
    return layers;
  },

  /**
   *  Asynchronously traverse `layers`, calling handlers in the proper
   *  order.
   *
   *  @param {object}   context - The context passed to each handler.
   *  @param {iterator} layers - A set of layers to traverse.
   *  @param {string}   [method] - The method to trigger.
   *  @param {function} callback - Called upon completion or failure.
   */
  traverse : function(context, layers, method, callback) {
    var self = this;
    var layer, node, match, state, handlers;
    var ascending = layers;
    var descending = layers.reversed();
    var apex = R.iterate([ layers.reversed().next() ]);
    // Turn `layers` into a chain of iterators, first going up the stack,
    // then back down the stack.
    layers = R.chain(ascending, apex, descending);
    // Ensures that our `handlers` variable has a `remaining` method.
    handlers = R.iterate();
    var next = function(error) {
      // 1 An error has been passed to the `next` function.
      if(error) {
        // 1.1 Set the error property in our `context`.
        context.error = error;
        // 1.2 Execute the callback..
        callback.call(context, match, layer, state, method);
        // 1.3 Traversal has failed, end here.
        return undefined; // 1 :: END
      }
      // 2 Another handler is not currently available.
      if(!handlers.remaining()) {
        // 2.1 Another layer is not available.
        if(!layers.remaining()) {
          // 2.1.1 Execute the callback.
          callback && callback.call(context);
          // 2.1.2 Traversal has completed successfully.
          return undefined; // 2 :: END
        // 3 Another layer is available.
        } else {
          // 3.1 Determine the current state.
          // 3.1.1 We are climbing up the stack of layers.
          if( ascending.remaining() ) { state = 'before'; }
          // 3.1.2 We are at the top of the stack.
          else if( apex.remaining() ) { state = 'on'; }
          // 3.1.3 We are climbing down the stack of layers.
          else if( descending.remaining() ) { state = 'after'; }
          // 3.2 Get the next layer.
          layer = layers.next();
          // 3.2.1 Parse the layer.
          node = layer.node; match = layer.match;
          // 3.2.2 Create an iterator from the current states array.
          var states = R.iterate(self[state]);
          // 3.2.3 Define variables used in the while loop.
          var key, nodeStates, methodStates;
          // 3.3 While there are states...
          while(states.remaining()) {
            // 3.3.1 Get the next state.
            key = states.next();
            // 3.3.2 Get the `node`s `state`s handlers.
            nodeStates = node.states[key];
            // 3.3.3 If a `method` was provided...
            if(method && node.methods[method]) {
              // 3.3.3.1 Get the `node`s `method`s `state`s handlers.
              methodStates = node.methods[method].states[key];
            }
            // 3.3.4 If `state` is...
            switch(state) {
              // 3.3.4.1 *before* or *on*
              case 'before' :
              case 'on' :
                // 3.3.4.1.1 Add the `node`s states, then the `node`s
                // `method`s states (if any) to the `handlers` chain.
                handlers.push(nodeStates).push(methodStates);
                break; // 3.3.4 :: BREAK
              // 3.3.4.2 *after*
              case 'after' :
                // 3.3.4.1.1 Add the `node`s `method`s states (if any)
                // to the chain of `handlers`, followed by the `node`s
                // states.
                handlers.push(methodStates).push(nodeStates);
                break; // 3.3.4 :: BREAK
            }
          }
          // 3.4 The `handlers` chain has been reloaded, move along.
          next(); // 3 :: RECURSE
        }
      // 4 Another handler is available.
      } else {
        R.ensure(context, 'next', next);
        var handler = handlers.next()
        handler.call(context, match);
        if(!self.async) { next(); }
      }
    };
    R.ensure(context, 'next', next);
    next(); // Initiate the chain.
  },

  /**
   *  Attempt to traverse to `endpoint` in the routing table.
   *
   *  @param {string}   endpoint - The path to attempt to match.
   *  @param {string}   [method] - The method to match.
   *  @param {object}   args - An object whose keys are attached to the
   *                    context.
   *  @param {function} callback - Called upon completion or failure.
   */
  trigger : function(endpoint, method, args, callback) {
    endpoint = endpoint || '';
    var context = { error : null, next : null };
    for(var key in args) { context[key] = args[key]; }
    try {
      var layers = R.iterate(this.match(endpoint));
    } catch(error) {
      context.error = error;
      if(callback) { callback.call(context); }
      else { throw error; }
    }
    if(!context.error) { this.traverse(context, layers, method, callback); }
  }

};

module.exports = Elixir;
