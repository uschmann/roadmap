require('cheeba')(global);

var R = require('../');

describe('Auxiliary functions...', function() {

  describe('each...', function() {

    it('iterates over arguments', function() {
      var begin = [ 'test', 'ing', '123' ];
      var final = [ ];
      R.each(begin, function(arg) { final.push(arg); });
      final.toString().should.equal(begin.toString())
    });

  });

  describe('is...', function() {

    it('arguments', function() {
      R.isArguments(arguments).should.be.true;
      R.isArguments(null).should.be.false;
    });

    it('function', function() {
      R.isFunction(function() { }).should.be.true;
      R.isFunction({}).should.be.false;
    });

    it('string', function() {
      R.isString({}).should.be.false;
      R.isString('').should.be.true;
    });

    it('number', function() {
      R.isNumber({}).should.be.false;
      R.isNumber(1).should.be.true;
    });

    it('date', function() {
      R.isDate(new Date()).should.be.true;
      R.isDate({}).should.be.false;
    });

    it('regex', function() {
      R.isRegExp(/ /).should.be.true;
      R.isRegExp('').should.be.false;
    });

    it('undefined', function() {
      R.isUndefined(undefined).should.be.true;
      R.isUndefined(null).should.be.false;
      R.isUndefined({ }).should.be.false;
    });

    it('object', function() {
      R.isObject({}).should.be.true;
      R.isObject(function() { }).should.be.true;
      R.isObject('').should.be.false;
    });

    it('array', function() {
      R.isArray([]).should.be.true;
      R.isArray({}).should.be.false;
    });

    it('empty', function() {
      R.isEmpty([]).should.be.true;
      R.isEmpty([1]).should.be.false;
      R.isEmpty({}).should.be.true;
      R.isEmpty({'a': 'b'}).should.be.false;
    });

  });

  describe('has...', function() {

    it('determines property existence', function() {
      a = { test : 1 };
      R.has(a, 'test').should.be.true;
      R.has(a, 'ing').should.be.false;
    });

  });

  describe('contains...', function() {

    it('properly determines containment', function() {
      R.contains([ 'test', 'ing' ], 'ing').should.equal.true;
      R.contains([ 'test', 'ing' ], '123').should.equal.false;
    });

  });

  describe('count...', function() {

    it('can count occurrences', function() {
      R.count('testingtest', 't').should.equal(4);
      R.count([ 1, 2, 3, 2 ], 2).should.equal(2);
      R.count([ 1, 2, 3, 4 ], 5).should.equal(0);
    });

  });

  describe('every...', function() {

    it('properly determines truthfulness of an array', function() {
      R.every([ true, true, false, true], function(x) { return x; })
        .should.be.false;
      R.every([ true, true, true, true], function(x) { return x; })
        .should.be.true;
      R.every([], function(x) { return x; })
        .should.be.true;
    });

  });

  describe('ensure...', function() {

    it('creates an empty object by default', function() {
      var test = { };
      R.ensure(test, 'ing');
      test.ing.should.eql({ });
    });

    it('can create values', function() {
      var test = { };
      R.ensure(test, 'ing', '123');
      test.ing.should.equal('123');
    });

    it('does not overwrite values', function() {
      var test = { ing : 'abc' };
      R.ensure(test, 'ing', '123');
      test.ing.should.equal('abc');
    });

    it('returns the value at key', function() {
      var test = { };
      R.ensure(test, 'ing', '123').should.equal('123');
    });

    it('returns the value at key', function() {
      var test = { };
      R.ensure(test, 'ing', '123').should.equal('123');
    });

    it('sets an object\'s key in strict mode', function() {
      var test = { ing : { } };
      R.ensure(test.ing, 'abc', '123', true).should.equal('123');
      test.should.eql({ ing : { abc : '123' } });
    });

    it('sets an array\'s key in strict mode', function() {
      var test = { ing : [ ] };
      R.ensure(test.ing, '0', '123', true).should.equal('123');
      test.should.eql({ ing : [ '123' ] });
    });

    it('does not clobber values in strict mode', function() {
      var test = { ing : false };
      expect(R.ensure(test, 'ing', '123', true)).to.be.undefined;
      test.ing.should.equal(false);
    });

  });

  describe('flatten...', function() {
    var data = [ 1, [ 2, [ 3, [ 4, [ 5, [ 6 ], 7 ], 8 ], 9 ], 0 ] ];

    it('ignores empty arrays', function() {
      R.flatten([ [ ], [ 'test' ] ]).should.eql([ 'test' ]);
    });

    it('can flatten an array', function() {
      var flat = R.flatten(data, [ ], -1);
      flat.should.eql([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]);
    });

    it('abides by it\'s max depth parameter', function() {
      var flat = R.flatten(data, [ ], 2);
      flat.should.eql([ 1, 2, 3, [ 4, [ 5, [ 6 ], 7 ], 8 ], 9, 0 ]);
    });

  });

  describe('squash...', function() {
    var data = [ 1, [ 2, [ 3, [ 4, [ 5, [ 6 ], 7 ], 8 ], 9 ], 0 ] ];

    it('completely flattens an array', function() {
      var flat = R.squash(data);
      flat.should.eql([ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]);
    });

  });

  describe('waterfall...', function() {

    it('can fall through an array', function(done) {
      R.waterfall([ function() { done(); } ]);
    });

    it('can call a function upon completion', function(done) {
      R.waterfall([ function(next) { 
        next();
      } ], function(err) {
        done(); 
      });
    });

    it('can be passed an initial set of arguments', function(done) {
      R.waterfall([ function(next, a, b) {
        a.should.equal('a');
        b.should.equal('b');
        done();
      } ], null, [ 'a', 'b' ])
    });

    it('can be passed a context', function(done) {
      R.waterfall([ function(next) {
        this.test.should.equal('ing');
        next();
      }, function(next) {
        this.test.should.equal('ing');
        done();
      }], null, null, { test : 'ing' } );
    });

    describe('the "next" function', function() {

      it('can be called with no arguments', function(done) {
        R.waterfall([
          function(next) {
            next();
          },
          function(next, msg) {
            msg.should.equal('hi there');
            done();
          }
        ], null, [ 'hi there' ]);
      });

      it('can be called with arguments', function(done) {
        R.waterfall([
          function(next, msg) {
            next(msg + ' there');
          },
          function(next, msg) {
            msg.should.equal('hi there');
            done();
          }
        ], null, [ 'hi' ]);
      });

      it('can be passed an Error', function(done) {
        R.waterfall([
          function(next, msg) {
            next(new Error('fail!'), msg);
          },
          function(next) {
            false.should.be.true;
          } ],
          function(err, msg) {
            msg.should.equal('still here');
            err.message.should.equal('fail!')
            done();
          }, [ 'still here' ]);
      });

    });

  });

  describe('token...', function() {

    it('can replace tokens in a string', function() {
      var token = R.token('(test)+', 'ing');
      token('test/test').should.equal('ing/ing');
    });

  });

  describe('tokenize...', function() {

    var tokens = [ R.token('alpha', 'A'), R.token('beta', 'B') ];

    it('tokenizes a string', function() {
      R.tokenize('alpha/beta/gamma/alpha/beta/gamma', tokens).should
        .equal('A/B/gamma/A/B/gamma');
    });

  });

  describe('regify...', function() {

    it('doesn\'t break regular expressions', function() {
      R.regify('/home.*').should.equal('/home.*');
      R.regify('/home(.*)').should.equal('/home(.*)');
      R.regify('/home(page[0-9])*').should.equal('/home(page[0-9])*');
    });

    it('allows the use of colon in url', function() {
      R.regify('/folder/::home').should.equal('/folder/:home');
    });

    it('can regify a url', function() {
      R.regify('/folder/::home/:user:/*')
        .should.equal('/folder/:home/([._a-zA-Z0-9-]+)/*');
    });

  });

  describe('sanitize...', function() {

    it('can clamp the beginning', function() {
      R.sanitize('/test///ing//', '/', null, null, -1)
        .should.equal('test/ing/');
    });

    it('can clamp the end', function() {
      R.sanitize('/test///ing//', '/', null, null, 1)
        .should.equal('/test/ing');
    });

    it('can clamp both ends', function() {
      R.sanitize('/test///ing//', '/', null, null)
        .should.equal('test/ing');
    });

    it('can ignore both ends', function() {
      R.sanitize('/test///ing//', '/', null, null, false)
        .should.equal('/test/ing/');
    });

    it('replaces single character', function() {
      R.sanitize('/test///ing//', '/').should.equal('test/ing');
    });

    it('replaces only a minimum number of characters', function() {
      R.sanitize('/test//ing///123//', '/', 3)
        .should.equal('test//ing/123');
    });

    it('replaces a minimum number of characters with count characters',
        function() {
      R.sanitize('/test/ing///123//', '/', 3, 2)
        .should.equal('test/ing//123');
    });

  });

  describe('group...', function() {

    it('allows single segment groups', function() {
      R.group([ '(test)' ], '', '(', ')').should.eql([ '(test)' ]);
    });

    it('properly groups segments', function() {
      R.group(['test' , 'in(g' , ')1' , '(23' , '4)' , 'x'] , '' ,'(',')')
        .should.eql([ 'test', 'in(g)1', '(234)', 'x' ]);
    });

    it('properly handles multi-element groups', function() {
      R.group([ 'te(st', '12', '34', '56', 'in)g', 'x' ], '', '(', ')')
        .should.eql([ 'te(st123456in)g', 'x' ]);
    });

    it('properly handles nested groups', function() {
      R.group([ 'te(st', '12(', '34', '56)', 'in)g', 'x' ], '', '(', ')')
        .should.eql([ 'te(st12(3456)in)g', 'x' ]);
    });

    it('can ignore malformed groups', function() {
      R.group([ 'te(st', '12(', '34', '56)', 'ing', 'x' ],
          '', '(', ')', true)
        .should.eql([ 'te(st12(3456)ingx' ]);
    });

    it('can throw an error upon malformed groups', function() {
      var e;
      try {
        R.group([ 'te(st', '12(', '34', '56)', 'ing', 'x' ], '', '(', ')')
          .should.eql([ 'te(st12(3456)ingx' ]);
      } catch(_e) { e = _e }
      e.should.be.defined;
    });

  });

  describe('split...', function() {

    it('splits a string by delimiter', function() {
      R.split('hello/there', '/').should.eql([ 'hello', 'there' ]);
    });

    it('splits a string with multiple groups', function() {
      R.split('(\\d+)/([A-Za-z]+)', '/')
        .should.eql([ '(\\d+)', '([A-Za-z]+)' ]);
    });

    it('keeps regular expression groups intact', function() {
      R.split('hello/?([^/]*)/([^/]*)?', '/')
        .should.eql([ 'hello', '?([^/]*)', '([^/]*)?' ]);
    });

  });

  describe('parse...', function() {

    it('returns an empty array for the root path', function() {
      R.parse('/', '/').should.eql([]);
    });

    it('parses a path', function() {
      R.parse('/test/ing', '/').should.eql([ 'test', 'ing' ]);
    });

    it('parses a dirty path', function() {
      R.parse('//test////ing///', '/').should.eql([ 'test', 'ing' ]);
    });

    it('parses a path with tokens', function() {
      var alpha = R.token('alpha', 'A');
      var beta = R.token('beta', 'B');
      var tokens = [ alpha, beta ];
      var parsed = R.parse('/test/alpha/ing/beta', '/', tokens);
      parsed.should.eql([ 'test', 'A', 'ing', 'B' ]);
    });

    it('parses a path with params', function() {
      R.parse('/test/ing/:number', '/').should.eql([
        'test', 'ing', '([._a-zA-Z0-9-]+)'
      ]);
    });

    it('parses a path with a regex', function() {
      R.parse('/test/ing/([a-z0-9]+)', '/').should.eql([
        'test', 'ing', '([a-z0-9]+)'
      ]);
    });

    it('parses a path with a split group', function() {
      R.parse('/test/ing/([a-z/0-9]+)', '/').should.eql([
        'test', 'ing', '([a-z/0-9]+)'
      ]);
    });

  });

});
