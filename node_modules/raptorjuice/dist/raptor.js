(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/** @module RaptorJuice */

var R = exports;

var slice = Array.prototype.slice;
var toString = Object.prototype.toString;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 *  A factory function which returns an iterator object.
 *
 *  @param {array}      array - The array to iterate over.
 *  @param {integer}    [start] - The index to start iteration at.
 *  @param {string}     [dir] - The direction to traverse. Either
 *                      *backward* or *forward*.
 *
 *  @returns {object} An iterator object.
 */
exports.iterate = function iterate(array, start, dir) {
  array = array || [ ]; // Allow empty iterators to be created.
  var transform = null;
  var generate = null;
  var limit = null;
  var i = start || 0;
  var length = array && array.length || 0;
  dir = ( dir === 'backward' ? dir : 'forward' );
  var morph = function(item, rel) {
    return ( transform ? transform.call(this, item, rel) : item );
  };
  return {

    length : function() { return length; },

    data : function() { return array; },

    index : function() { return i; },

    direction : function() { return dir; },

    cursor : function(force) {
      return this.data()[this.index() - 1] || force && this.next();
    },

    transform : function(_transform) {
      transform = _transform; return this;
    },

    generate : function(_generate) {
      generate = _generate; return this;
    },

    limit : function(_limit) {
      limit = _limit; return this;
    },

    next : function() {
      var k;
      var _i = i;
      var rel = function(j) { return array[_i + j]; }
      if( (this.remaining() - 1) < 0 ) {
        if(limit) {
          if(R.isNumber(limit)) {
            if(this.cursor() >= limit) { return undefined };
          }
          else if(limit.call(this, rel)) { return undefined; }
        }
        if(generate) { k = generate.call(this, rel); }
        if(R.isUndefined(k)) { return undefined; }
      }
      switch(dir) {
        case 'forward' :
          if(!R.isUndefined(k)) { this.push(k); }
          return morph.call(this, array[i++], rel);
        case 'backward':
          if(!R.isUndefined(k)) { this.push(1, k); }
          return morph.call(this, array[--i], rel);
      }
    },

    move : function(_i, opts) {
      opts = opts || { };
      if(opts.relative) {
        switch(dir) {
          case 'forward' : _i += i; break;
          case 'backward' : _i = ( i - _i + 1); break;
        }
      }
      if( !opts.unsafe && ( ( _i < 0 ) || ( _i > this.length() ) ) ) {
        throw new Error('RaptorJuice.iterate.move: Trying to move the ' +
          'cursor to a non-existent index.');
      }
      i = _i;
      return this;
    },

    skip : function(inc) {
      this.move(inc, { relative : true });
      return this;
    },

    fire : function(pos, abs) {
      abs = abs || abs && pos;
      pos = ( pos ? pos : 0 );
      this.move(pos, !abs);
      while(this.remaining()) { this.next(); }
      return this;
    },

    prev : function() {
      var ret = this.reverse().next();
      this.reverse();
      return ret;
    },

    remaining : function() {
      var count;
      switch(dir) {
        case 'forward' :
          count = this.length() - this.index();
          count = ( count >= 0 ? count : 0 );
          break;
        case 'backward':
          count = this.index();
      }
      return count;
    },

    reverse : function(opts) {
      dir = ( dir === 'forward' ? 'backward' : 'forward' );
      if(opts && opts.discard) { this.next(); }
      return this;
    },

    reset: function() { return this.reverse().deplete().reverse(); },

    copy : function(_start) {
      return iterate(slice.call(array), _start || this.index(), dir);
    },

    reversed : function() { return this.copy().deplete().reverse(); },

    deplete : function() {
      switch(dir) {
        case 'forward' : i = length; break;
        case 'backward': i = 0; break;
      }
      return this;
    },


    push : function(j, _array) {
      // 1 If _array is undefined...
      if(R.isUndefined(_array)) {
        // 1.1 If j is undefined, return this object.
        if(R.isUndefined(j)) { return this; } // 1.1 :: RETURN
        // 1.2 Otherwise...
        // 1.2 Only an array was provided as an argument.
        // 1.2 Set `_array` to the actual array.
        _array = j;
        // 1.2 Set the insertion point to the end of the model.
        j = length;
      }
      // 2 If `_array` is not an array, return this object.
      // 3 Our parameters look good...
      // 3. If we are inserting before the cursor...
      if( j < this.index() ) {
        // 3.1 Increment our index by the number of elements inserted.
        i += _array.length;
      }
      // 3. If the model is not empty and we are inserting at the end of
      // the model...
      if( this.length() && ( j === this.length() ) ) {
        // 3.2 Increment `j` by one.
        j += 1;
        // 3.2. If the cursor is *also* at the end of the array...
        //if( this.index() === this.length() ) {
          // 3.2.1 Increment `i` by the number of items added.
          //i += _array.length;
        //}
      }
      // 3. 
      array = [ ].concat(array.slice(0, j-1), _array, array.slice(j-1));
      length = array.length;
      return this;
    },

    pop : function(j, count) {
      // Set `count` to '1', if it is not already defined.
      count = count || 1;
      // Set `j` to `length` if it is not defined.
      j = (j || length ) - 1;
      // 1 Check paramaters.
      // 1.1 Return if our parameters are invalid.
      if( (j < 0) || (count < 1) ) { return undefined; } // 1.1 :: END
      // 1.2 Trying to remove elements that do not exist?
      if( !( (j + count) <= length ) ) { return undefined; } // 1.2 :: END
      // 2 Removal affects the cursor.
      // 2.1 The cursor resides in the range of removed items.
      if( (this.index() > j) && (this.index() <= count) ) { i = j; }
      // 2.2 The curser resides after the range of removed items.
      if( ( j + count ) <= this.index() ) { i -= count; }
      // 3 Update model.
      // 3.1 Remove the specified range of indicies.
      var _array = array;
      array = [ ].concat(array.slice(0, j), array.slice(j + count));
      // 3.2 Update our `length` variable.
      length = array.length;
      // 3.3 Return the removed elements.
      return _array.slice(j, j + count); // 3 :: RETURN
    },

    filter : function(_callback) {
      var count = 0;
      var replace = [ ];
      var removed = [ ];
      R.each(array, function(item, j) {
        if(_callback(item, i)) {
          replace.push(item);
        } else {
          removed.push(item);
          if(j <= i) { count++; }
        }
      });
      i -= count;
      length = replace.length;
      array = replace;
      return removed;
    }

  };
}

exports.chain = function() {
  var iterators = R.iterate();
  var iterator = R.iterate();
  var length = 0;
  var i = 0;
  var chain = {
    next : function() {
      if(!iterator.remaining()) {
        // TODO: Remove iterator from the model once they are exhausted.
        if(!iterators.remaining()) {
          return undefined;
        }
        iterator = iterators.next()
      }
      i++; return iterator.next();
    },
    index : function() { return i; },
    remaining : function() { return length - i; },
    add : function() {
      var args = R.iterate(slice.apply(arguments));
      var arg;
      while(args.remaining()) {
        arg = args.next();
        // TODO: What if an iterator is reversed while part of a chain?
        // Its `remaining` count will change, but this change will not
        // be reflected in this `chain`.
        length += arg.remaining();
        iterators.push([ arg ]);
      }
      return this;
    }
  };
  return chain.add.apply(chain, arguments);
}

exports.populate = function(object, array) {
  R.iterate(array).transform(function(u, n) {
    object[u] = n(+1);
    this.skip(1);
  }).fire();
};

/**
 *  Ensure that `key` is defined in `ctx` and return the coresponding value.
 *
 *  @param {object}   ctx - The context in which to ensure `key`.
 *  @param {string}   key - The name to ensure.
 *  @param {*}        [val] - The value used if `key` is not defined
 *                    in `ctx`.
 *  @param {boolean}  strict - 
 *  @returns {*}      A reference to the value at `ctx`[`key`].
 */
exports.ensure = function(ctx, key, val, strict) {
  if(!strict) {
    return ctx[key] = ctx[key] || ( val || { } );
  } else {
    if(R.isUndefined(ctx[key]) || R.isObject(ctx[key])) {
      return ctx[key] = ctx[key] || ( val || { } );
    } else {
      return undefined;
    }
  }
}

function valid(object) {
  return !R.isFunction(object) && (R.isObject(object) || R.isArray(object));
}

/**
 * Unwrap an object.
 */
exports.unwrap = function(root, path, force) {

  var segments = R.iterate(R.sanitize(R.sanitize(path, '.'), ':')
    .split('.')).transform(function(v) {
      v = R.iterate(v.split(':'));
      return { key : v.pop(1)[0], indicies : v };
    });

  var nodes = [ ];
  var object = root;
  var key, index, indicies;
  (function peel(segment) {
    if( !force && !valid(object) ) { return object = undefined; }
    index = undefined;
    key = segment.key; indicies = segment.indicies;
    parent = object;
    object = R.ensure(object, key, null, !force);
    if( force && !valid(object) ) { object = parent[key] = { }; }
    nodes.push({ object : object, parent : parent, key : key });
    while(indicies.remaining()) {
      if( !force && !valid(object) ) { return object = undefined; }
      key = undefined;
      index = indicies.next();
      parent = object;
      object = R.ensure(object, index);
      if( force && !valid(object) ) { object = parent[index] = { }; }
      nodes.push({ object : object, parent : parent, index : index });
    }
    if(segments.remaining()) { peel(segments.next()) };
  })(segments.next());

  return {
    nodes : nodes, object : object, parent : parent,
    key : key, index : index, root : root, path : path
  };
};

exports.set = function(root, path, value, force) {
  var data = R.unwrap(root, path, force);
  if(!data.object) {
    throw new Error('RaptoJuice.set: Trying to overwrite data or set ' +
      'a property on an object which cannot have one.');
  }
  return data.parent[data.key || data.index] = value;
};

exports.get = function(root, path) { return R.unwrap(root, path).object; };

/**
 *  Similar to `print` but with a timestamp.
 *
 *  @param {string}   format - The string to insert parameters into.
 *  @param {...*}     parameters - The parameters to format.
 */
exports.log = function() {
  console.log.apply(console, arguments);
};

/**
 *  Inverts the call structure for **Object.prototype.toString**.
 *
 *  @param {*}          obj - The object to convert to a string.
 *  @returns {string}   The string representation of `obj`.
 */
exports.toString = function() { return toString.apply(arguments); };

/**
 *  Inverts the call structure for **Object.prototype.hasOwnProperty**.
 *
 *  @param {object}   obj - The object to look for `key` in.
 *  @param {string}   key - The key to look in `obj` for.
 *  @returns {*}      The value of `obj`[`key`].
 */
exports.has = function(obj, key) { return hasOwnProperty.call(obj, key); };

/**
 *  Determine if `array` contains `item`.
 *
 *  @param {array}      array - The array to look through.
 *  @param {*}          item  - Something to look through `array` for.
 *  @returns {boolean}  *true* if `item` exists in `array`, else *false*.
 */
exports.contains = function(array, item) {
  return !(array.indexOf(item) < 0);
};

/**
 *  Count occurrences of `token` in `array`.
 *
 *  @param {array}  array - The array to look through.
 *  @param {*}      token - The item to look for.
 */
exports.count = function(array, token) {
  var count = 0;
  for(var i in array) { (array[i] === token) && count++; }
  return count;
}

/**
 *  Iterates over `args` and invokes the supplied callback with an 
 *  `item`, `index` and `length` of the array.
 *
 *  @param {array}      args - The array of items to iterate over.
 *  @param {function}   callback - The function to call for each index.
 */
exports.each = function(args, callback) {
  if(!args) { return; }
  var i = -1; while(args[++i]) { callback(args[i], i + 1, args.length); };
};

// TODO Document these methods.
var types = [
  'Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'
];
exports.each(types, function(type) {
  exports['is' + type] = function(obj) {
    return toString.call(obj) === '[object ' + type + ']';
  };
});

/**
 *  Determine if `obj` is **undefined**.
 *
 *  @param {*}          obj - The object to test.
 *  @returns {boolean}  **true** if `obj` is **undefined**, 
 *                      else **false**.
 */
exports.isUndefined = function(obj) { return typeof obj === 'undefined'; };

/**
 *  Returns *true* if `obj` is anything other than *undefined*.
 *
 *  @param {*}          obj - The object to test.
 *  @returns {boolean}  **true** unless `obj` is **undefined**, 
 *                      then **false**.
 */
exports.isDefined = function(obj) { return !R.isUndefined(obj); };

/**
 *  Determine if `obj` is an **Object**.
 *
 *  @param {*}          obj - The object to test.
 *  @returns {boolean}  **true** if `obj` is an **Object**, else **false**.
 */
exports.isObject = function(obj) { return obj === Object(obj); };

/**
 *  Determine if `obj` is an **Array**.
 *
 *  @param {*}  obj - The object to test.
 *  @returns {boolean}  **true** if `obj` is an **Array**, else **false**.
 */
exports.isArray = function(obj) {
  return toString.call(obj) === '[object Array]';
};

/**
 *
 *  Determine if `obj` is empty. Works with **Objects** and **Arrays**.
 *
 *  @param {*}  obj - The object to test.
 *  @returns {boolean}  **true** if `obj` is empty, else **false**.
 */
exports.isEmpty = function(obj) {
  if(obj === null) {
    return true;
  }
  if(R.isArray(obj) || R.isString(obj)) {
    return obj.length === 0;
  }
  for(var key in obj) {
    return false;
  }
  return true;
};

/**
 * Executes a callback on each element of the array until `callback`
 * returns a **false** value. If `array` is empty, **true** is returned.
 *
 * @param {Array}     array - The array upon which to iterate over.
 * @param {Function}  callback - The callback which determines
 * @returns {boolean} True if callback evaluated truthy for all items.
 */
exports.every = function(array, callback) {
  for (var i = 0; i < array.length; i++) {
    if (callback(array[i], i, array) === false) {
      return false;
    }
  }
  return true;
};

/**
 * Flatten an array in a forward, recursive manner. The function limits
 * itself to `max` recursions.
 *
 * @param {Array}     branch - The branch of the tree to flatten.
 * @param {Array}     flat - The array into which results are pushed.
 * @param {Integer}   max - The maximum level of recursion.
 * @param {Integer}   depth - The current level of recursion.
 * @returns {array}   An array flattened to `max` depth.
 */
exports.flatten = function(branch, flat, max, depth) {
  flat = flat || [ ]; max = max || 1;
  depth = ( depth ? depth + 1 : 1);
  for(var i in branch) {
    if(R.isArray(branch[i])) {
      if((max < 0) || (depth <= max)) {
        R.flatten(branch[i], flat, max, depth);
      } else { flat.push(branch[i]); }
    } else { flat.push(branch[i]); }
  }
  return flat;
};

/**
 * Completely flatten an array.
 *
 * @param {Array}   array - The array to squash.
 * @returns {array}  A completely flattened copy of the original array.
 */
exports.squash = function(array) {
  return R.flatten(array, [ ], -1); // Flatten to an infinite depth.
};

// Helper function for waterfall.
function fall(context, func, args) {
  func.apply(context, R.flatten(args));
}

/**
 * Asynchronously fall through an array, and finally call a function. As
 * functions in the array are invoked, their first parameter is a
 * callback which must be executed for the chain to continue. Arguments
 * passed to this callback, a.k.a. the "next" function, will be passed as
 * parameters to the following function in the chain. If "next" is invoked
 * with arguments, the arguments from the previous call to "next" will be
 * passed to the function following in the chain. If an Error is passed
 * to "next", the remaining functions in the chain will be skipped and
 * `final` will be called with the set of arguments last passed to "next".
 *
 * @param {Array}     array - The array through which to fall.
 * @param {Function}  final - A function to call upon completion or error.
 * @param {Array}     args  - An array of arguments to pass to the first
 *                            callback, or directly to final.
 */
exports.waterfall = function(array, final, args, context) {
  var i = 0;
  var error = null;
  var next = function() {
    var _args = slice.call(arguments);
    if(_args[0] instanceof Error) { error = _args.shift(); }
    if(!R.isEmpty(_args)) { args = _args }; // If the calling function
    // passed anything other than an error to next, we replace the
    // current set of falling args with the args passed to next.
    if( (i >= (array.length - 1)) || error) {
      final && fall(context, final, [ error, args ]);
    } else {
      array[++i] && fall(context, array[i], [ next, args ]);
    }
  }
  if(array[0]) { // Start recursion;
    fall(context, array[0], [ next, args ]);
  } else {
    final && fall(context, final, [ error, args ]);
  }
};

/**
 *  Generates a function which replaces all occurences of `token` in
 *  `string` with `replacement`.
 *
 *  @param {string|regex} token - The string or regex to replace.
 *  @param {string}       replacement - The replacement string.
 *  @returns {string}     The tokenized string.
 */
exports.token = function(token, replacement) {
  var compiled = new RegExp(token, 'g');
  return function (string) {
    return string.replace(compiled, replacement);
  }; 
};

/**
 *  Applies an array of `tokens` to `string`.
 *
 *  @param {string}   string - The string to tokenize.
 *  @param {array}   tokens - An object containing `token` functions to
 *  @returns {string} The tokenized string.
 */
exports.tokenize = function(string, tokens) {
  var mod = string;
  R.each(tokens, function(token) {
    mod = token(mod);
  });
  return mod;
};

/**
 *  Expands named matches and wildcards.
 *
 *  @param {string}   string - The string to regify.
 *  @param {object}   tokens - On containing `token` functions an keys.
 *  @returns {string} The regified string.
 */
exports.regify = function(string) {
  // TODO Implement SEARCH and ESCAPE from original code.
  return string.replace(/:([^\/]+)/ig, function(a, b) {
    switch(a[1]) {
      case ':': return b;
      default: return '([._a-zA-Z0-9-]+)';
    }
  });
};

/**
 *  Group `segments` with `delimiter` by `begin` and `end`.
 *  
 *  @param {array}  segments - An array of path segments.
 *  @param {string} delimiter - The delimiter to join groups with.
 *  @param {string} begin - The charater which starts a group.
 *  @param {string} end - The character which ends a group.
 *  @returns {array} An array where groups have been joined by `delimiter`.
 */
exports.group = function(segments, delimiter, begin, end, explode) {
  explode = !explode;
  segments = R.iterate(segments);
  var groups = R.iterate().generate(function() { return [ [ ] ]; });
  var group;
  var diff = 0;
  var open = 0;
  var close = 0;
  for(var segment; segment = segments.next();) {
    group = group || groups.next();
    var chars = R.iterate(segment);
    while(chars.remaining()) {
      switch(chars.next()) {
        case begin : open ++; break;
        case end : close ++; break;
      }
    }
    group.push(segment);
    diff =+ open - close;
    if( (diff === 0) && segments.remaining() ) { group = groups.next(); }
  }
  // There were an uneven number of group delimiters, incomplete groups
  // exist.
  if(diff && explode) {
    throw new Error('RaptorJuice.group: Improperly terminated groups.');
  }
  var res = [ ];
  groups.reset();
  while(groups.remaining()) {
    res.push(groups.next().join(delimiter));
  }
  return R.flatten(res);
};

/**
 *  Replace `min` many sequential `character`s in `string` with `count`
 *  `character`s. The scope of replacement encompasses the entire `string`.
 *  If clamp is `0`, both ends of the string will be truncated, if negative,
 *  the beginning, if positive the end.
 *
 *  @param {string}   string - The string to sanitize.
 *  @param {string}   character - The character.
 *  @param {integer}  [min = 1] - The minimum number of sequential
 *                                `character`s.
 *  @param {integer}  [count = 1] - The number of `character`s to replace
 *                                  each match with.
 *  @param {integer}  [clamp = 0] - Determines truncation.
 *  @returns {string} A sanitized string.
 */
exports.sanitize = function(string, character, min, count, clamp) {
  min = min || 1; count = count || 1;
  var skip = R.isDefined(clamp);
  clamp = ( clamp ? ( clamp < 1 ? -1 : 1 ) : 0 );
  var dupe = RegExp('\\' + character + '{' + min + ',}', 'g');
  var replacement = [ ];
  for(var i = 0; i < count; i++) { replacement.push(character); }
  replacement = replacement.join('');
  string = string.replace(dupe, replacement);
  if ( skip && !clamp ) { return string; }
  var trim = ( clamp ? '' : '|' );
  if(clamp <= 0) { trim = '^\\' + character + '+' + trim; }
  if(clamp >= 0) { trim += '\\' + character + '+$' }
  return string.replace(RegExp(trim, 'g'), '');
};

/**
 *  Splits a `path` with `delimiter` but keeps regular expressions intact.
 *
 *  @param {string}   path - The path to split.
 *  @param {string}   delimiter - The delimiter to split `path` with.
 *  @returns {array}  The array of segments of `path` split by `delimiter`.
 */
exports.split = function(path, delimiter) {
  var segments = path.split(delimiter);
  return R.group(segments, delimiter, '(', ')');
};

/**
 *  Combine *split*, *regify* and *sanitize* into a single function.
 *
 *  @param {string}     path - The string to parse.
 *  @param {delimiter}  delimiter - The delimiter to split `path` with.
 *  @param {array}      tokens - An array of `token`s.
 *  @returns {array}    An sanitized array of segments.
 */
exports.parse = function(path, delimiter, tokens) {
  var tokenized = R.tokenize(path, tokens);
  var sanitized = R.sanitize(tokenized, delimiter);
  return R.split(R.regify(sanitized), delimiter);
};

},{}]},{},[1])